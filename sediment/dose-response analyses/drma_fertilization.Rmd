---
title: "Effects of sediment on the fertilization of coral gametes"
author: "Lillian J. Tuttle"
date: "9/25/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(mixmeta)
library(dosresmeta)
library(splines)

effectsize <- read.csv("data/effectsize_ALL.csv", header=T)
```
  
```{r, echo=FALSE, warning=FALSE}
#Looking at data
#head(effectsize) 

#a lot of variables (columns) are factors instead of numeric/doubles/integers
effectsize <- effectsize %>% #converting appropriate columns to numeric...
  mutate_at(vars(ES, Hedges_d, Var_d, SE_d, CI_lo_d, CI_up_d, Sed_level_standardized, Sed_exposure, Sed_exposure_mg_d_L), as.character) %>% 
  mutate_at(vars(ES, Hedges_d, Var_d, SE_d, CI_lo_d, CI_up_d, Sed_level_standardized, Sed_exposure, Sed_exposure_mg_d_L), as.numeric)
#head(effectsize) #"double"-check!

#Now create a new variable that has both Genus and species, remove sediment burial experiments, and remove irrelevant rows (non-controls, -treatments, or -baselines)
effectsize <- effectsize %>%
  mutate(Gsp = paste(Updated_Genus, Updated_species, sep = "_")) %>% 
  filter(Binary_sed_burial=="0") %>%
  filter(!Control=="-1")
#head(effectsize)

#Separate into deposited sediment (DS) and suspended sediment (SS) datasets, WITH CONTROLS
ES_DS <- effectsize %>% filter(DS_SS=="DS")
ES_SS <- effectsize %>% filter(DS_SS=="SS")

#Second dataset that that removes controls (Control == c("1","2"))
effectsize2 <- effectsize %>% filter(Control=="0")
#effectsize2 #"double"-check!
ES_adult <- effectsize2 %>% filter(Coral_age_class=="adult")
ES_immat <- effectsize2 %>% filter(!Coral_age_class=="adult")
#ES_adult %>% count(Gsp)
#ES_adult %>% count(Updated_Genus)
#ES_immat %>% count(Gsp)
#ES_immat %>% count(Updated_Genus)

#Separate into deposited sediment (DS) and suspended sediment (SS) datasets, WITHOUT CONTROLS
ES_DS2 <- effectsize2 %>% filter(DS_SS=="DS")
ES_SS2 <- effectsize2 %>% filter(DS_SS=="SS")

#Now separate into independent dataset for each coral response for SUSPENDED SEDIMENT
ES_SS_fertilization <- ES_SS %>% filter(Response == "fertilization")
#ES_SS_fertilization %>% count(Ref) #n=10 studies from 6 articles

#Now remove outlier -- see figures below -- no obvious reason to remove it other than how extraordinarily extreme the effect size is, so may want to create models both with and without it
ES_SS_fertilization_b <- ES_SS_fertilization %>% filter(Comparison != 'JL')
#ES_SS_fertilization_b #will have 1 less Comparison than dataset with the outlier. Otherwise, same.
``` 
  
These datasets contain information from multiple articles (**Ref_name**) and studies/experiments (**Ref**) within those articles about the effects of SUSPENDED sediment on the **fertilization success** of coral gametes. I would like to explore the dose-response relationship between sediment 'dose' and the effect size, estimated here as the standardized mean difference between treatment and control, in terms of Hedges' *d*:

- Hedges' *d* is the standardized mean difference between the treatment and control groups (Hedges and Olkin 1985). Each study may have multiple Hedges' *d* calculations, one for each treatment-control comparison at each time-point.   

- 'Dose' can be quantified as sediment exposure concentration (mg/L), exposure duration (days), or as "cumulative exposure", for which I multiply concentration and duration (mg x day/L).

Each study/experiment (Ref) may contain multiple sets of controls and treatments (due to using multiple species or sediment types, for instance). Thus, I have added two categorical vectors, '**Comparison**' and 'Control', which group each set of control-treatment comparisons into a unique two-letter code, within which is one control (Control=="1") and at least one treatment (Control=="0"). **Therefore, 'Comparison' is nested within 'Ref', which is further nested within 'Ref_name'.**

```{r, echo=FALSE}
#Using dosresmeta to calculate Hedges' d and variance of d
covar_SS_fertilization <- by(ES_SS_fertilization, ES_SS_fertilization$Comparison, function(x) 
  covar.smd(Tx_mean, Tx_sd, Tx_n, "smd", method="hedges", data = x))
ES_SS_fertilization$smd <- unlist(lapply(covar_SS_fertilization, function(x) x$y))
ES_SS_fertilization$vmd <- unlist(lapply(covar_SS_fertilization, function(x) x$v))

#same but without outlier (see figures below)
covar_SS_fertilization_b <- by(ES_SS_fertilization_b, ES_SS_fertilization_b$Comparison, function(x) 
  covar.smd(Tx_mean, Tx_sd, Tx_n, "smd", method="hedges", data = x))
ES_SS_fertilization_b$smd <- unlist(lapply(covar_SS_fertilization_b, function(x) x$y))
ES_SS_fertilization_b$vmd <- unlist(lapply(covar_SS_fertilization_b, function(x) x$v))

#Looking at data to make sure smd and vmd added as columns
#ES_SS_fertilization
#ES_SS_fertilization_b

#Removing controls for modeling
ES_SS_fertilization2 <- subset(ES_SS_fertilization, Control=="0")
ES_SS_fertilization_b2 <- subset(ES_SS_fertilization_b, Control=="0")

#Looking at data to make sure controls were removed
#ES_SS_fertilization2
#ES_SS_fertilization_b2
``` 
  
# I. Fertilization success  

## A. Suspended Sediment, Dataset WITH Outlier  
  
### 1. Plots  
I calculated the standardized mean difference in terms of Hedges' *d* and plot it here with respect to exposure concentration. I did this first for a Hedges' *d* that I calculated before importing the data to R and again for a Hedges' *d* that is calculated by the dosresmeta::covar.smd function.

```{r, echo=FALSE, warning=FALSE}
#EXPOSURE CONCENTRATION vs. effect size, by study
#Using previously calculated Hedges' d and variance of d
ggplot(ES_SS_fertilization2, 
       aes(x = Sed_level_standardized,
           y = Hedges_d,
           color = Ref,
           ymin = Hedges_d-Var_d,
           ymax = Hedges_d+Var_d)) + 
  geom_pointrange() +
  ggtitle("Fertilization success rate") +
  labs(x = "Sediment exposure concentration (mg/L)",
       y = "Effect size (Hedges' d +/- s.d., manual calculation)",
       color = "Study") +
  geom_abline(intercept=0, slope=0) +
  theme_classic() +
  scale_x_log10(limits = c(1,1000), breaks=c(1,10,100,1000), 
                label=c("1","10","100","1000"))
#Using dosresmeta's calculation of Hedges' d and variance of d
ggplot(ES_SS_fertilization2, 
       aes(x = Sed_level_standardized,
           y = smd,
           color = Ref,
           ymin = smd-vmd,
           ymax = smd+vmd)) + 
  geom_pointrange() +
  ggtitle("Fertilization success rate") +
  labs(x = "Sediment exposure concentration (mg/L)",
       y = "Effect size (Hedges' d +/- s.d., dosresmeta calculation)",
       color = "Study") +
  geom_abline(intercept=0, slope=0) +
  theme_classic() +
  scale_x_log10(limits = c(1,1000), breaks=c(1,10,100,1000), 
                label=c("1","10","100","1000"))


#EXPOSURE CONCENTRATION vs. effect size, by SEDIMENT TYPE
#Using previously calculated Hedges' d and variance of d
ggplot(ES_SS_fertilization2, 
       aes(x = Sed_level_standardized,
           y = smd,
           color = Sed_grain_category,
           shape = Sed_source,
           ymin = smd-vmd,
           ymax = smd+vmd)) + 
  geom_pointrange() +
  ggtitle("Fertilization success rate") +
  labs(x = "Sediment exposure concentration (mg/L)",
       y = "Effect size (Hedges' d +/- s.d., dosresmeta calculation)",
       color = "Sediment relative\ngrain size",
       shape = "Sediment source") +
  geom_abline(intercept=0, slope=0) +
  theme_classic() +
  scale_x_log10(limits = c(1,1000), breaks=c(1,10,100,1000), 
                label=c("1","10","100","1000"))
ggplot(ES_SS_fertilization2, 
       aes(x = Sed_level_standardized,
           y = smd,
           color = Sed_grain_class,
           shape = Sed_mineralogy,
           ymin = smd-vmd,
           ymax = smd+vmd)) + 
  geom_pointrange() +
  ggtitle("Fertilization success rate") +
  labs(x = "Sediment exposure concentration (mg/L)",
       y = "Effect size (Hedges' d +/- s.d., dosresmeta calculation)",
       color = "Sediment\ngrain class",
       shape = "Sediment mineralogy") +
  geom_abline(intercept=0, slope=0) +
  theme_classic() +
  scale_x_log10(limits = c(1,1000), breaks=c(1,10,100,1000), 
                label=c("1","10","100","1000"))

#EXPOSURE CONCENTRATION vs. effect size, by PHYLOGENY
#Using previously calculated Hedges' d and variance of d
ggplot(ES_SS_fertilization2, 
       aes(x = Sed_level_standardized,
           y = smd,
           color = Gsp,
           ymin = smd-vmd,
           ymax = smd+vmd)) + 
  geom_pointrange() +
  ggtitle("Fertilization success rate") +
  labs(x = "Sediment exposure concentration (mg/L)",
       y = "Effect size (Hedges' d +/- s.d., dosresmeta calculation)",
       color = "Species") +
  geom_abline(intercept=0, slope=0) +
  theme_classic() +
  scale_x_log10(limits = c(1,1000), breaks=c(1,10,100,1000), 
                label=c("1","10","100","1000"))

#EXPOSURE CONCENTRATION vs. effect size, by OCEAN and REGION
#Using previously calculated Hedges' d and variance of d
ggplot(ES_SS_fertilization2, 
       aes(x = Sed_level_standardized,
           y = smd,
           color = Region,
           shape = Ocean,
           ymin = smd-vmd,
           ymax = smd+vmd)) + 
  geom_pointrange() +
  ggtitle("Fertilization success rate") +
  labs(x = "Sediment exposure concentration (mg/L)",
       y = "Effect size (Hedges' d +/- s.d., dosresmeta calculation)",
       color = "Region",
       shape = "Ocean") +
  geom_abline(intercept=0, slope=0) +
  theme_classic() +
  scale_x_log10(limits = c(1,1000), breaks=c(1,10,100,1000), 
                label=c("1","10","100","1000"))
```
  
It is interesting that there is a difference between how I calculated Hedges' *d* and how *dosresmeta* appears to calculate it. But in both cases, there may be a negative effect of sediment exposure on effect size, perhaps especially for *Acropora digitifera*. Any effect of geography (ocean and region) may be obscured or co-linear with phylogeny. I still need to investigate the effects of sediment type (source, origin, grain size). I also conduct analyses both with and without the outlier.
  
### 2. Model Fitting 
The following set of functions model fixed and random (nested) effects WITHOUT accounting for within-comparison (or within-study) correlations. The output for each is a univariate, random-effects meta-regression.

```{r, echo=FALSE, warning=FALSE}
#?mixmeta

# Organizational Note: 
#All models have exposure concentration as its predictor. 
#All models with 'c' at the end of its name have fixed slopes, random intercepts.
#All models with 'd' at the end of its name have random slopes and intercepts.

# LINEAR FIXED AND RANDOM EFFECTS NOT ACCOUNTING FOR WITHIN-STUDY CORRELATIONS
mod_SS_fertil_1c <- mixmeta(smd ~ Sed_level_standardized, S = vmd,
                       random =  ~ 1 | Comparison,
                       data = ES_SS_fertilization2, method = "ml")
mod_SS_fertil_1d <- mixmeta(smd ~ Sed_level_standardized, S = vmd,
                      random =  ~ Sed_level_standardized | Comparison,
                      data = ES_SS_fertilization2, method = "ml")

# LINEAR FIXED AND RANDOM, NESTED EFFECTS NOT ACCOUNTING FOR WITHIN-STUDY CORRELATIONS
mod_SS_fertil_2c <- mixmeta(smd ~ Sed_level_standardized, S = vmd,
                       random =  ~ 1 | Ref/Comparison,
                       data = ES_SS_fertilization2, method = "ml")
mod_SS_fertil_2d <- mixmeta(smd ~ Sed_level_standardized, S = vmd,
                      random =  ~ Sed_level_standardized | Ref/Comparison,
                      data = ES_SS_fertilization2, method = "ml")

# LINEAR FIXED AND RANDOM, NESTED EFFECTS NOT ACCOUNTING FOR WITHIN-STUDY CORRELATIONS
mod_SS_fertil_3c <- mixmeta(smd ~ Sed_level_standardized, S = vmd,
                       random =  ~ 1 | Ref_name/Comparison,
                       data = ES_SS_fertilization2, method = "ml")
mod_SS_fertil_3d <- mixmeta(smd ~ Sed_level_standardized, S = vmd,
                      random =  ~ Sed_level_standardized | Ref_name/Comparison,
                      data = ES_SS_fertilization2, method = "ml")

# LINEAR FIXED AND RANDOM, NESTED EFFECTS NOT ACCOUNTING FOR WITHIN-STUDY CORRELATIONS
mod_SS_fertil_4c <- mixmeta(smd ~ Sed_level_standardized, S = vmd,
                       random =  ~ 1 | Ref_name/Ref/Comparison,
                       data = ES_SS_fertilization2, method = "ml")
mod_SS_fertil_4d <- mixmeta(smd ~ Sed_level_standardized, S = vmd,
                       random =  ~ Sed_level_standardized | Ref_name/Ref/Comparison,
                       data = ES_SS_fertilization2, method = "ml")
```

To account for within-comparison correlations in the mixmeta model, I replace the 'S' argument with a 'control' argument, which requires me to provide the covariance matrices, as done with the covar.smd function. 

```{r, echo=FALSE, warning=FALSE}
# COMPUTE THE WITHIN-COMPARISON CORRELATIONS 
# already done above but code repeated here...
#covar_SS_fertilization <- by(ES_SS_fertilization, ES_SS_fertilization$Comparison, function(x) 
#  covar.smd(Tx_mean, Tx_sd, Tx_n, "smd", method="hedges", data = x))

# LINEAR FIXED AND RANDOM EFFECTS ACCOUNTING FOR WITHIN-COMPARISON CORRELATIONS
#Code for covariance matrix to include for addSlist for Comparison random effect
newlist_FERT <- list(NA)
for (i in seq(1,length(covar_SS_fertilization))) {
newlist_FERT[i] <- list(covar_SS_fertilization[[i]]$S)
}
mod_SS_fertil_5c <- mixmeta(smd ~ Sed_level_standardized,
                       random = ~ 1 | Comparison,
                       data=ES_SS_fertilization2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT))
mod_SS_fertil_5d <- mixmeta(smd ~ Sed_level_standardized,
                       random = ~ Sed_level_standardized | Comparison,
                       data=ES_SS_fertilization2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT))


# LINEAR FIXED AND RANDOM, NESTED EFFECTS ACCOUNTING FOR WITHIN-COMPARISON & WITHIN-STUDY CORRELATIONS
#Code for covariance matrix to include for addSlist for Ref/Comparison
newlist_FERT2 <- list(NA) #collects the list of covariance matrices for the block diag matrix by reference for the nested hierarchial ref/comparison
templist_FERT <- list(NA) #holds temp list of covariance matrices associated with each reference
templist_FERT2 <-list(NA)
reflista <- ES_SS_fertilization %>% distinct(Ref,Ref_name,Comparison)
reflist <- reflista[,1]
for (i in seq(1,length(unique(reflista$Ref))))  {
  #pull the elements from covar_SS_fertilization_b that are all from the same reference [i]
  templist_FERT[i] <-list(covar_SS_fertilization[reflist==unique(reflista$Ref)[i]])
  for (j in seq(1,length(templist_FERT[[i]]))) {
  #for each comparison in the reference, pull out the covar matrices (element $S) and put in into templist_FERT2
     templist_FERT2[j] <- list(templist_FERT[[i]][[j]]$S)
  }
  #turn list of covars from all comparison in one reference into block diag matrix
  newlist_FERT2[i] <- list(bdiagMat(templist_FERT2))
  templist_FERT2 <- list(NA)
}
mod_SS_fertil_6c <- mixmeta(smd ~ Sed_level_standardized,
                       random = ~ 1 | Ref/Comparison,
                       data=ES_SS_fertilization2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT2))
mod_SS_fertil_6d <- mixmeta(smd ~ Sed_level_standardized,
                       random = ~ Sed_level_standardized | Ref/Comparison,
                       data=ES_SS_fertilization2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT2))


# LINEAR FIXED AND RANDOM, NESTED EFFECTS ACCOUNTING FOR WITHIN-COMPARISON & WITHIN-STUDY CORRELATIONS
#Code for covariance matrix to include for addSlist for Ref_name/Comparison
newlist_FERT3 <- list(NA) #collects the list of covariance matrices for the block diag matrix by reference for the nested hierarchial Ref_name/Comparison
templist_FERT3 <- list(NA) #holds temp list of covariance matrices associated with each reference
templist_FERT4 <-list(NA)
reflista <- ES_SS_fertilization %>% distinct(Ref,Ref_name,Comparison)
reflist <- reflista[,2]
for (i in seq(1,length(unique(reflista$Ref_name))))  {
  #pull the elements from covar_SS_fertilization_b that are all from the same reference [i]
  templist_FERT3[i] <-list(covar_SS_fertilization[reflist==unique(reflista$Ref_name)[i]])
  for (j in seq(1,length(templist_FERT3[[i]]))) {
  #for each comparison in the reference, pull out the covar matrices (element $S) and put in into templist_FERT4
     templist_FERT4[j] <- list(templist_FERT3[[i]][[j]]$S)
  }
  #turn list of covars from all comparison in one reference into block diag matrix
  newlist_FERT3[i] <- list(bdiagMat(templist_FERT4))
  templist_FERT4 <- list(NA)
}
mod_SS_fertil_7c <- mixmeta(smd ~ Sed_level_standardized,
                       random = ~ 1 | Ref_name/Comparison,
                       data=ES_SS_fertilization2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT3))
mod_SS_fertil_7d <- mixmeta(smd ~ Sed_level_standardized,
                       random = ~ Sed_level_standardized | Ref_name/Comparison,
                       data=ES_SS_fertilization2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT3))
```
  
And now to compare relative fit of linear models...

```{r, echo=FALSE, warning=FALSE}
# Model Comparisons
AIC(mod_SS_fertil_1c, mod_SS_fertil_2c, mod_SS_fertil_3c, mod_SS_fertil_4c, mod_SS_fertil_5c, mod_SS_fertil_6c, mod_SS_fertil_7c, mod_SS_fertil_1d, mod_SS_fertil_2d, mod_SS_fertil_3d, mod_SS_fertil_4d, mod_SS_fertil_5d, mod_SS_fertil_6d, mod_SS_fertil_7d) 
#of these, model 6d has lowest AIC
```
  
And now to evaluate residuals of models...

```{r, echo=FALSE, warning=FALSE}
# Residuals vs. Fitted Plots and Normal Q-Q Plot
op <- par(mfrow = c(1,2), mar = c(2,2,4,1))

resid_d <- resid(mod_SS_fertil_6d)
fitted_d <- fitted(mod_SS_fertil_6d)
plot(fitted_d, resid_d, main = "D: smd ~ mg_L, control = addSlist,
     random =  ~ mg_L | Ref/Comparison")
abline(0,0)

qqnorm(resid_d)
qqline(resid_d)

par(op)
```
  
Patterns:
1.  There could be non-linearities that need to be accounted for.
2.  Very strong outlier in negative residual land!
3.  First let's try a log transformation of sediment exposure before adding non-linear models.
  
Now let's check out a log, base 10 transformation of sediment exposure to see if it improves the residuals of the models.

```{r, echo=FALSE, warning=FALSE}
#?mixmeta

# Organizational Note: 
#All models have exposure concentration as its predictor. 
#All models with 'c' at the end of its name have fixed slopes, random intercepts.
#All models with 'd' at the end of its name have random slopes and intercepts.

# LINEAR FIXED AND RANDOM EFFECTS NOT ACCOUNTING FOR WITHIN-STUDY CORRELATIONS
log_mod_SS_fertil_1c <- mixmeta(smd ~ log10(Sed_level_standardized), S = vmd,
                       random =  ~ 1 | Comparison,
                       data = ES_SS_fertilization2, method = "ml")
log_mod_SS_fertil_1d <- mixmeta(smd ~ log10(Sed_level_standardized), S = vmd,
                      random =  ~ log10(Sed_level_standardized) | Comparison,
                      data = ES_SS_fertilization2, method = "ml")

# LINEAR FIXED AND RANDOM, NESTED EFFECTS NOT ACCOUNTING FOR WITHIN-STUDY CORRELATIONS
log_mod_SS_fertil_2c <- mixmeta(smd ~ log10(Sed_level_standardized), S = vmd,
                       random =  ~ 1 | Ref/Comparison,
                       data = ES_SS_fertilization2, method = "ml")
log_mod_SS_fertil_2d <- mixmeta(smd ~ log10(Sed_level_standardized), S = vmd,
                      random =  ~ log10(Sed_level_standardized) | Ref/Comparison,
                      data = ES_SS_fertilization2, method = "ml")

# LINEAR FIXED AND RANDOM, NESTED EFFECTS NOT ACCOUNTING FOR WITHIN-STUDY CORRELATIONS
log_mod_SS_fertil_3c <- mixmeta(smd ~ log10(Sed_level_standardized), S = vmd,
                       random =  ~ 1 | Ref_name/Comparison,
                       data = ES_SS_fertilization2, method = "ml")
log_mod_SS_fertil_3d <- mixmeta(smd ~ log10(Sed_level_standardized), S = vmd,
                      random =  ~ log10(Sed_level_standardized) | Ref_name/Comparison,
                      data = ES_SS_fertilization2, method = "ml")

# LINEAR FIXED AND RANDOM, NESTED EFFECTS NOT ACCOUNTING FOR WITHIN-STUDY CORRELATIONS
log_mod_SS_fertil_4c <- mixmeta(smd ~ log10(Sed_level_standardized), S = vmd,
                       random =  ~ 1 | Ref_name/Ref/Comparison,
                       data = ES_SS_fertilization2, method = "ml")
log_mod_SS_fertil_4d <- mixmeta(smd ~ log10(Sed_level_standardized), S = vmd,
                       random =  ~ log10(Sed_level_standardized) | Ref_name/Ref/Comparison,
                       data = ES_SS_fertilization2, method = "ml")
```

To account for within-comparison correlations in the mixmeta model, I replace the 'S' argument with a 'control' argument, which requires me to provide the covariance matrices, as done with the covar.smd function. 

```{r, echo=FALSE, warning=FALSE}
# COMPUTE THE WITHIN-COMPARISON CORRELATIONS 
# already done above but code repeated here...
#covar_SS_fertilization <- by(ES_SS_fertilization, ES_SS_fertilization$Comparison, function(x) 
#  covar.smd(Tx_mean, Tx_sd, Tx_n, "smd", method="hedges", data = x))


# LINEAR FIXED AND RANDOM EFFECTS ACCOUNTING FOR WITHIN-COMPARISON CORRELATIONS
#Code for covariance matrix to include for addSlist for Comparison random effect
newlist_FERT_log <- list(NA)
for (i in seq(1,length(covar_SS_fertilization))) {
newlist_FERT_log[i] <- list(covar_SS_fertilization[[i]]$S)
}
log_mod_SS_fertil_5c <- mixmeta(smd ~ log10(Sed_level_standardized),
                       random = ~ 1 | Comparison,
                       data=ES_SS_fertilization2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT_log))
log_mod_SS_fertil_5d <- mixmeta(smd ~ log10(Sed_level_standardized),
                       random = ~ log10(Sed_level_standardized) | Comparison,
                       data=ES_SS_fertilization2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT_log))


# LINEAR FIXED AND RANDOM, NESTED EFFECTS ACCOUNTING FOR WITHIN-COMPARISON & WITHIN-STUDY CORRELATIONS
#Code for covariance matrix to include for addSlist for Ref/Comparison
newlist_FERT_log2 <- list(NA) #collects the list of covariance matrices for the block diag matrix by reference for the nested hierarchial ref/comparison
templist_FERT_log <- list(NA) #holds temp list of covariance matrices associated with each reference
templist_FERT_log2 <-list(NA)
reflista <- ES_SS_fertilization %>% distinct(Ref,Ref_name,Comparison)
reflist <- reflista[,1]
for (i in seq(1,length(unique(reflista$Ref))))  {
  #pull the elements from covar_SS_fertilization_b that are all from the same reference [i]
  templist_FERT_log[i] <-list(covar_SS_fertilization[reflist==unique(reflista$Ref)[i]])
  for (j in seq(1,length(templist_FERT_log[[i]]))) {
  #for each comparison in the reference, pull out the covar matrices (element $S) and put in into templist_FERT_log2
     templist_FERT_log2[j] <- list(templist_FERT_log[[i]][[j]]$S)
  }
  #turn list of covars from all comparison in one reference into block diag matrix
  newlist_FERT_log2[i] <- list(bdiagMat(templist_FERT_log2))
  templist_FERT_log2 <- list(NA)
}
log_mod_SS_fertil_6c <- mixmeta(smd ~ log10(Sed_level_standardized),
                       random = ~ 1 | Ref/Comparison,
                       data=ES_SS_fertilization2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT_log2))
log_mod_SS_fertil_6d <- mixmeta(smd ~ log10(Sed_level_standardized),
                       random = ~ log10(Sed_level_standardized) | Ref/Comparison,
                       data=ES_SS_fertilization2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT_log2))


# LINEAR FIXED AND RANDOM, NESTED EFFECTS ACCOUNTING FOR WITHIN-COMPARISON & WITHIN-STUDY CORRELATIONS
#Code for covariance matrix to include for addSlist for Ref_name/Comparison
newlist_FERT_log3 <- list(NA) #collects the list of covariance matrices for the block diag matrix by reference for the nested hierarchial Ref_name/Comparison
templist_FERT_log3 <- list(NA) #holds temp list of covariance matrices associated with each reference
templist_FERT_log4 <-list(NA)
reflista <- ES_SS_fertilization %>% distinct(Ref,Ref_name,Comparison)
reflist <- reflista[,2]
for (i in seq(1,length(unique(reflista$Ref_name))))  {
  #pull the elements from covar_SS_fertilization_b that are all from the same reference [i]
  templist_FERT_log3[i] <-list(covar_SS_fertilization[reflist==unique(reflista$Ref_name)[i]])
  for (j in seq(1,length(templist_FERT_log3[[i]]))) {
  #for each comparison in the reference, pull out the covar matrices (element $S) and put in into templist_FERT_log4
     templist_FERT_log4[j] <- list(templist_FERT_log3[[i]][[j]]$S)
  }
  #turn list of covars from all comparison in one reference into block diag matrix
  newlist_FERT_log3[i] <- list(bdiagMat(templist_FERT_log4))
  templist_FERT_log4 <- list(NA)
}
log_mod_SS_fertil_7c <- mixmeta(smd ~ log10(Sed_level_standardized),
                       random = ~ 1 | Ref_name/Comparison,
                       data=ES_SS_fertilization2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT_log3))
log_mod_SS_fertil_7d <- mixmeta(smd ~ log10(Sed_level_standardized),
                       random = ~ log10(Sed_level_standardized) | Ref_name/Comparison,
                       data=ES_SS_fertilization2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT_log3))
```
    
### 3. Model Comparison and Summary
And now to compare relative fit of logarithmic models...
```{r, echo=FALSE, warning=FALSE}
# Model Comparisons
AIC(log_mod_SS_fertil_1c, log_mod_SS_fertil_2c, log_mod_SS_fertil_3c, log_mod_SS_fertil_4c, log_mod_SS_fertil_5c, log_mod_SS_fertil_6c, log_mod_SS_fertil_7c, log_mod_SS_fertil_1d, log_mod_SS_fertil_2d, log_mod_SS_fertil_3d, log_mod_SS_fertil_4d, log_mod_SS_fertil_5d, log_mod_SS_fertil_6d, log_mod_SS_fertil_7d) 
#of these, model 3d has lowest AIC (but 2d,7d within 2 AIC)
```
  
And now to evaluate residuals of models...
```{r, echo=FALSE, warning=FALSE}
# Residuals vs. Fitted Plots and Normal Q-Q Plots
op <- par(mfrow = c(2,2), mar = c(2,2,4,1))

resid_logd <- resid(log_mod_SS_fertil_3d)
fitted_logd <- fitted(log_mod_SS_fertil_3d)
plot(fitted_logd, resid_logd, main = "smd ~ log_mg_L, S = vmd,
     random =  ~ log_mg_L | Ref_name/Comparison")
abline(0,0)

resid_logd2 <- resid(log_mod_SS_fertil_2d)
fitted_logd2 <- fitted(log_mod_SS_fertil_2d)
plot(fitted_logd2, resid_logd2, main = "smd ~ log_mg_L, S = vmd,
     random =  ~ log_mg_L | Ref/Comparison")
abline(0,0)

qqnorm(resid_logd)
qqline(resid_logd)
qqnorm(resid_logd2)
qqline(resid_logd2)

par(op)
```
  
Patterns:
1.  Residuals for all models are very similar.
2.  Looking MUCH better, with less extreme residuals, with exception of one very strong outlier in negative residual land!
3.  Let's check out non-linear options to see if it helps with outlier. Otherwise, will need to analyze with and without this data-point.
  
These are much improved from the non-logged models! There is still one outlier, so I will need to analyze the data with and without it. Out of curiosity, I will also fit non-linear models to the data, to see if there is any improvement...
  
```{r, echo=FALSE, warning=FALSE}
# Calculate 1st and 3rd quartiles of exposure, to assign 'knots' for non-linear models
log_mg_L <- log10(ES_SS_fertilization2$Sed_level_standardized)
summary(log_mg_L)
#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 0.6021  1.5051  1.9657  1.8956  2.3617  3.0103 


# NON-LINEAR FIXED AND RANDOM EFFECTS ACCOUNTING FOR WITHIN-COMPARISON & WITHIN-STUDY CORRELATIONS
log_mod_SS_fertil_NL3d <- mixmeta(smd ~ ns(log_mg_L, knots = c(1.5051,2.3617)), 
                         random = ~ ns(log_mg_L, knots = c(1.5051,2.3617)) | Ref_name/Comparison, 
                         data = ES_SS_fertilization2, method = "ml", S = vmd)
log_mod_SS_fertil_NL2d <- mixmeta(smd ~ ns(log_mg_L, knots = c(1.5051,2.3617)), 
                         random = ~ ns(log_mg_L, knots = c(1.5051,2.3617)) | Ref/Comparison, 
                         data = ES_SS_fertilization2, method = "ml", S = vmd)


# SIMPLIFY THE MODEL BY ALLOWING NON-LINEARITY ONLY IN FIXED EFFECTS
log_mod_SS_fertil_NL3d_2 <- update(log_mod_SS_fertil_NL3d, random = ~ log_mg_L | Ref_name/Comparison)
log_mod_SS_fertil_NL2d_2 <- update(log_mod_SS_fertil_NL2d, random = ~ log_mg_L | Ref/Comparison)

AIC(log_mod_SS_fertil_NL3d, log_mod_SS_fertil_NL3d_2, log_mod_SS_fertil_NL2d, log_mod_SS_fertil_NL2d_2) #NL3d_2 or 2d_2
```
  
And now to evaluate residuals of non-linear models...
```{r, echo=FALSE, warning=FALSE}
# Residuals vs. Fitted Plots and Normal Q-Q Plots
op <- par(mfrow = c(2,2), mar = c(2,2,4,1))

new_resid_d <- resid(log_mod_SS_fertil_NL3d_2)
new_fitted_d <- fitted(log_mod_SS_fertil_NL3d_2)
plot(new_fitted_d, new_resid_d, main = "smd ~ ns(log_mg_L), S = vmd,
     random =  ~ log_mg_L | Ref_name/Comparison")
abline(0,0)

new_resid_d2 <- resid(log_mod_SS_fertil_NL2d_2)
new_fitted_d2 <- fitted(log_mod_SS_fertil_NL2d_2)
plot(new_fitted_d2, new_resid_d2, main = "smd ~ ns(log_mg_L), S = vmd,
     random =  ~ log_mg_L | Ref/Comparison")
abline(0,0)

qqnorm(new_resid_d)
qqline(new_resid_d)
qqnorm(new_resid_d2)
qqline(new_resid_d2)

par(op)
```
  
Patterns:
1.  No obvious changes/improvements in residuals from linear versions.
2.  Still strong outlier in negative residual land! Let's check out models without outlier.
  
The residuals for the non-linear, logarithmic models are very similar to the analogous linear, logarithmic models. I will defer to the linear models because they are simpler.
  
  
### 4. Best-Fit Model Summary
  
#### i. Exposure concentration is PREDICTOR
Now I will predict the effect size along the exposure range and plot with confidence intervals.  

```{r, echo=FALSE, warning=FALSE}
summary(log_mod_SS_fertil_3d)
test <- qtest(log_mod_SS_fertil_3d)
print(test, digits=2)
log_mod_SS_fertil_3d2 <- mixmeta(smd ~ log10(Sed_level_standardized) + Gsp, S = vmd,
                      random =  ~ log10(Sed_level_standardized) | Ref_name/Comparison,
                      data = ES_SS_fertilization2, method = "ml")
AIC(log_mod_SS_fertil_3d, log_mod_SS_fertil_3d2)

# PREDICT THE EFFECT SIZE FOR 30.4 mg/L FROM TWO MODELS (LOAEL identified by binary analyses)
#predict(log_mod_SS_fertil_3d, newdata=data.frame(Sed_level_standardized=30.4), ci=TRUE)
# PREDICT THE EFFECT SIZE FOR 25 mg/L FROM TWO MODELS (NOAEL identified by binary analyses)
#predict(log_mod_SS_fertil_3d, newdata=data.frame(Sed_level_standardized=25), ci=TRUE)

# PREDICT THE EFFECT SIZE AND PLOT WITH CONFIDENCE INTERVALS
pred_log_mod_SS_fertil_3d <- predict(log_mod_SS_fertil_3d, newdata=ES_SS_fertilization2, ci=TRUE)
ES_SS_fertilization2_CI4 <- cbind(ES_SS_fertilization2, pred_log_mod_SS_fertil_3d)
#head(ES_SS_fertilization2_CI4)
min_conc_d <- ES_SS_fertilization2_CI4 %>% 
  mutate(overlap0 = 0 >= ci.lb & 0 <= ci.ub) %>% 
  filter(overlap0==FALSE) %>% 
  filter(ci.ub<0) %>% 
  summarize(min_conc_d=min(Sed_level_standardized))
min_conc_d2 <- as.numeric(min_conc_d)

ggplot(ES_SS_fertilization2_CI4, 
       aes(x = Sed_level_standardized,
           y = smd,
           color = Ref,
           ymin = smd-vmd,
           ymax = smd+vmd)) + 
  geom_pointrange() +
  labs(x = "Sediment exposure concentration (mg/L)",
       y = expression("Effect size (Hedges'"~italic(d)~"+/- variance of"~italic(d)~")"),
       color = "Study") +
  geom_abline(intercept=0, slope=0) +
  geom_vline(xintercept=min_conc_d2, linetype="dashed", color = "red") +
  geom_line(aes(x = Sed_level_standardized, y = fit), inherit.aes=FALSE) +
  geom_ribbon(aes(x = Sed_level_standardized, y = smd,
                  ymin = ci.lb, ymax = ci.ub), 
              fill = "grey70", alpha = .15, 
              show.legend=FALSE, inherit.aes=FALSE) +
  theme_classic() +
  scale_x_log10(limits = c(1,1000), breaks=c(1,10,100,1000,min_conc_d2), 
                label=c("1","10","100","1000",round(min_conc_d2,digits=1)))
```
   
   
## B. Suspended Sediment, WITHOUT outlier  
  
### 1. Plots  
I calculated the standardized mean difference in terms of Hedges' *d* and plot it here with respect to exposureconcentration. I did this first for a Hedges' *d* that I calculated before importing the data to R and again for a Hedges' *d* that is calculated by the dosresmeta::covar.smd function.

```{r, echo=FALSE, warning=FALSE}
#EXPOSURE CONCENTRATION vs. effect size, by study
#Using previously calculated Hedges' d and variance of d
ggplot(ES_SS_fertilization_b2, 
       aes(x = Sed_level_standardized,
           y = Hedges_d,
           color = Ref,
           ymin = Hedges_d-Var_d,
           ymax = Hedges_d+Var_d)) + 
  geom_pointrange() +
  ggtitle("Fertilization success rate") +
  labs(x = "Sediment exposure concentration (mg/L)",
       y = "Effect size (Hedges' d +/- s.d., manual calculation)",
       color = "Study") +
  geom_abline(intercept=0, slope=0) +
  theme_classic() +
  scale_x_log10(limits = c(1,1000), breaks=c(1,10,100,1000), 
                label=c("1","10","100","1000"))
#Using dosresmeta's calculation of Hedges' d and variance of d
ggplot(ES_SS_fertilization_b2, 
       aes(x = Sed_level_standardized,
           y = smd,
           color = Ref,
           ymin = smd-vmd,
           ymax = smd+vmd)) + 
  geom_pointrange() +
  ggtitle("Fertilization success rate") +
  labs(x = "Sediment exposure concentration (mg/L)",
       y = "Effect size (Hedges' d +/- s.d., dosresmeta calculation)",
       color = "Study") +
  geom_abline(intercept=0, slope=0) +
  theme_classic() +
  scale_x_log10(limits = c(1,1000), breaks=c(1,10,100,1000), 
                label=c("1","10","100","1000"))


#by SEDIMENT TYPE
#Using previously calculated Hedges' d and variance of d
ggplot(ES_SS_fertilization_b2, 
       aes(x = Sed_level_standardized,
           y = smd,
           color = Sed_source,
           shape = Sed_grain_category,
           ymin = smd-vmd,
           ymax = smd+vmd)) + 
  geom_pointrange() +
  ggtitle("Fertilization success rate") +
  labs(x = "Sediment exposure concentration (mg/L)",
       y = "Effect size (Hedges' d +/- s.d., dosresmeta calculation)",
       color = "Sediment source",
       shape = "Sediment relative\ngrain size") +
  geom_abline(intercept=0, slope=0) +
  theme_classic() +
  scale_x_log10(limits = c(1,1000), breaks=c(1,10,100,1000), 
                label=c("1","10","100","1000"))
ggplot(ES_SS_fertilization_b2, 
       aes(x = Sed_level_standardized,
           y = smd,
           color = Sed_grain_class,
           shape = Sed_mineralogy,
           ymin = smd-vmd,
           ymax = smd+vmd)) + 
  geom_pointrange() +
  ggtitle("Fertilization success rate") +
  labs(x = "Sediment exposure concentration (mg/L)",
       y = "Effect size (Hedges' d +/- s.d., dosresmeta calculation)",
       color = "Sediment\ngrain class",
       shape = "Sediment mineralogy") +
  geom_abline(intercept=0, slope=0) +
  theme_classic() +
  scale_x_log10(limits = c(1,1000), breaks=c(1,10,100,1000), 
                label=c("1","10","100","1000"))

#by PHYLOGENY
#Using previously calculated Hedges' d and variance of d
ggplot(ES_SS_fertilization_b2, 
       aes(x = Sed_level_standardized,
           y = smd,
           color = Gsp,
           ymin = smd-vmd,
           ymax = smd+vmd)) + 
  geom_pointrange() +
  ggtitle("Fertilization success rate") +
  labs(x = "Sediment exposure concentration (mg/L)",
       y = "Effect size (Hedges' d +/- s.d., dosresmeta calculation)",
       color = "Species") +
  geom_abline(intercept=0, slope=0) +
  theme_classic() +
  scale_x_log10(limits = c(1,1000), breaks=c(1,10,100,1000), 
                label=c("1","10","100","1000"))

#by OCEAN and REGION
#Using previously calculated Hedges' d and variance of d
ggplot(ES_SS_fertilization_b2, 
       aes(x = Sed_level_standardized,
           y = smd,
           color = Region,
           shape = Ocean,
           ymin = smd-vmd,
           ymax = smd+vmd)) + 
  geom_pointrange() +
  ggtitle("Fertilization success rate") +
  labs(x = "Sediment exposure concentration (mg/L)",
       y = "Effect size (Hedges' d +/- s.d., dosresmeta calculation)",
       color = "Region",
       shape = "Ocean") +
  geom_abline(intercept=0, slope=0) +
  theme_classic() +
  scale_x_log10(limits = c(1,1000), breaks=c(1,10,100,1000), 
                label=c("1","10","100","1000"))
```
  
It is interesting that there is a difference between how I calculated Hedges' *d* and how *dosresmeta* appears to calculate it. But in both cases, there may be a negative effect of sediment exposure on effect size, perhaps especially for *Acropora digitifera*. Any effect of geography (ocean and region) may be obscured or co-linear with phylogeny (or vice versa). I still need to investigate the effects of sediment type (source, origin, grain size).
  
### 2. Model Fitting 
The following set of functions model fixed and random (nested) effects WITHOUT accounting for within-comparison (or within-study) correlations. The output for each is a univariate, random-effects meta-regression.

```{r, echo=FALSE, warning=FALSE}
#?mixmeta

# Organizational Note: 
#All models have exposure concentration as its predictor. 
#All models with 'c' at the end of its name have fixed slopes, random intercepts.
#All models with 'd' at the end of its name have random slopes and intercepts.

# LINEAR FIXED AND RANDOM EFFECTS NOT ACCOUNTING FOR WITHIN-STUDY CORRELATIONS
mod_SS_fertil_b_1c <- mixmeta(smd ~ Sed_level_standardized, S = vmd,
                       random =  ~ 1 | Comparison,
                       data = ES_SS_fertilization_b2, method = "ml")
mod_SS_fertil_b_1d <- mixmeta(smd ~ Sed_level_standardized, S = vmd,
                      random =  ~ Sed_level_standardized | Comparison,
                      data = ES_SS_fertilization_b2, method = "ml")

# LINEAR FIXED AND RANDOM, NESTED EFFECTS NOT ACCOUNTING FOR WITHIN-STUDY CORRELATIONS
mod_SS_fertil_b_2c <- mixmeta(smd ~ Sed_level_standardized, S = vmd,
                       random =  ~ 1 | Ref/Comparison,
                       data = ES_SS_fertilization_b2, method = "ml")
mod_SS_fertil_b_2d <- mixmeta(smd ~ Sed_level_standardized, S = vmd,
                      random =  ~ Sed_level_standardized | Ref/Comparison,
                      data = ES_SS_fertilization_b2, method = "ml")

# LINEAR FIXED AND RANDOM, NESTED EFFECTS NOT ACCOUNTING FOR WITHIN-STUDY CORRELATIONS
mod_SS_fertil_b_3c <- mixmeta(smd ~ Sed_level_standardized, S = vmd,
                       random =  ~ 1 | Ref_name/Comparison,
                       data = ES_SS_fertilization_b2, method = "ml")
mod_SS_fertil_b_3d <- mixmeta(smd ~ Sed_level_standardized, S = vmd,
                      random =  ~ Sed_level_standardized | Ref_name/Comparison,
                      data = ES_SS_fertilization_b2, method = "ml")

# LINEAR FIXED AND RANDOM, NESTED EFFECTS NOT ACCOUNTING FOR WITHIN-STUDY CORRELATIONS
mod_SS_fertil_b_4c <- mixmeta(smd ~ Sed_level_standardized, S = vmd,
                       random =  ~ 1 | Ref_name/Ref/Comparison,
                       data = ES_SS_fertilization_b2, method = "ml")
mod_SS_fertil_b_4d <- mixmeta(smd ~ Sed_level_standardized, S = vmd,
                       random =  ~ Sed_level_standardized | Ref_name/Ref/Comparison,
                       data = ES_SS_fertilization_b2, method = "ml")
```

To account for within-comparison correlations in the mixmeta model, I replace the 'S' argument with a 'control' argument, which requires me to provide the covariance matrices, as done with the covar.smd function. 

```{r, echo=FALSE, warning=FALSE}
# COMPUTE THE WITHIN-COMPARISON CORRELATIONS 
# already done above but code repeated here...
#covar_SS_fertilization_b <- by(ES_SS_fertilization_b, ES_SS_fertilization_b$Comparison, function(x) 
#  covar.smd(Tx_mean, Tx_sd, Tx_n, "smd", method="hedges", data = x))


# LINEAR FIXED AND RANDOM EFFECTS ACCOUNTING FOR WITHIN-COMPARISON CORRELATIONS
#Code for covariance matrix to include for addSlist for Comparison random effect
newlist_FERT_b <- list(NA)
for (i in seq(1,length(covar_SS_fertilization_b))) {
newlist_FERT_b[i] <- list(covar_SS_fertilization_b[[i]]$S)
}
mod_SS_fertil_b_5c <- mixmeta(smd ~ Sed_level_standardized,
                       random = ~ 1 | Comparison,
                       data=ES_SS_fertilization_b2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT_b))
mod_SS_fertil_b_5d <- mixmeta(smd ~ Sed_level_standardized,
                       random = ~ Sed_level_standardized | Comparison,
                       data=ES_SS_fertilization_b2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT_b))


# LINEAR FIXED AND RANDOM, NESTED EFFECTS ACCOUNTING FOR WITHIN-COMPARISON & WITHIN-STUDY CORRELATIONS
#Code for covariance matrix to include for addSlist for Ref/Comparison
newlist_FERT_b2 <- list(NA) #collects the list of covariance matrices for the block diag matrix by reference for the nested hierarchial ref/comparison
templist_FERT_b <- list(NA) #holds temp list of covariance matrices associated with each reference
templist_FERT_b2 <-list(NA)
reflista <- ES_SS_fertilization_b %>% distinct(Ref,Ref_name,Comparison)
reflist <- reflista[,1]
for (i in seq(1,length(unique(reflista$Ref))))  {
  #pull the elements from covar_SS_fertilization_b that are all from the same reference [i]
  templist_FERT_b[i] <-list(covar_SS_fertilization_b[reflist==unique(reflista$Ref)[i]])
  for (j in seq(1,length(templist_FERT_b[[i]]))) {
  #for each comparison in the reference, pull out the covar matrices (element $S) and put in into templist_FERT_b2
     templist_FERT_b2[j] <- list(templist_FERT_b[[i]][[j]]$S)
  }
  #turn list of covars from all comparison in one reference into block diag matrix
  newlist_FERT_b2[i] <- list(bdiagMat(templist_FERT_b2))
  templist_FERT_b2 <- list(NA)
}
mod_SS_fertil_b_6c <- mixmeta(smd ~ Sed_level_standardized,
                       random = ~ 1 | Ref/Comparison,
                       data=ES_SS_fertilization_b2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT_b2))
mod_SS_fertil_b_6d <- mixmeta(smd ~ Sed_level_standardized,
                       random = ~ Sed_level_standardized | Ref/Comparison,
                       data=ES_SS_fertilization_b2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT_b2))


# LINEAR FIXED AND RANDOM, NESTED EFFECTS ACCOUNTING FOR WITHIN-COMPARISON & WITHIN-STUDY CORRELATIONS
#Code for covariance matrix to include for addSlist for Ref_name/Comparison
newlist_FERT_b3 <- list(NA) #collects the list of covariance matrices for the block diag matrix by reference for the nested hierarchial Ref_name/Comparison
templist_FERT_b3 <- list(NA) #holds temp list of covariance matrices associated with each reference
templist_FERT_b4 <-list(NA)
reflista <- ES_SS_fertilization_b %>% distinct(Ref,Ref_name,Comparison)
reflist <- reflista[,2]
for (i in seq(1,length(unique(reflista$Ref_name))))  {
  #pull the elements from covar_SS_fertilization_b that are all from the same reference [i]
  templist_FERT_b3[i] <-list(covar_SS_fertilization_b[reflist==unique(reflista$Ref_name)[i]])
  for (j in seq(1,length(templist_FERT_b3[[i]]))) {
  #for each comparison in the reference, pull out the covar matrices (element $S) and put in into templist_FERT_b4
     templist_FERT_b4[j] <- list(templist_FERT_b3[[i]][[j]]$S)
  }
  #turn list of covars from all comparison in one reference into block diag matrix
  newlist_FERT_b3[i] <- list(bdiagMat(templist_FERT_b4))
  templist_FERT_b4 <- list(NA)
}
mod_SS_fertil_b_7c <- mixmeta(smd ~ Sed_level_standardized,
                       random = ~ 1 | Ref_name/Comparison,
                       data=ES_SS_fertilization_b2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT_b3))
mod_SS_fertil_b_7d <- mixmeta(smd ~ Sed_level_standardized,
                       random = ~ Sed_level_standardized | Ref_name/Comparison,
                       data=ES_SS_fertilization_b2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT_b3))
```
  
And now to compare relative fit of linear models...

```{r, echo=FALSE, warning=FALSE}
# Model Comparisons
AIC(mod_SS_fertil_b_1c, mod_SS_fertil_b_2c, mod_SS_fertil_b_3c, mod_SS_fertil_b_4c, mod_SS_fertil_b_5c, mod_SS_fertil_b_6c, mod_SS_fertil_b_7c, mod_SS_fertil_b_1d, mod_SS_fertil_b_2d, mod_SS_fertil_b_3d, mod_SS_fertil_b_4d, mod_SS_fertil_b_5d, mod_SS_fertil_b_6d, mod_SS_fertil_b_7d) 
#of these, model 6d has lowest AIC
```
  
And now to evaluate residuals of models...

```{r, echo=FALSE, warning=FALSE}
# Residuals vs. Fitted Plots and Normal Q-Q Plot
op <- par(mfrow = c(1,2), mar = c(2,2,4,1))

resid_d_b <- resid(mod_SS_fertil_b_6d)
fitted_d_b <- fitted(mod_SS_fertil_b_6d)
plot(fitted_d_b, resid_d_b, main = "D: smd ~ mg_L, control = addSlist,
     random =  ~ mg_L | Ref/Comparison")
abline(0,0)

qqnorm(resid_d_b)
qqline(resid_d_b)

par(op)
```
  
Patterns:
1.  There could be non-linearities that need to be accounted for?
2.  First let's check out a log-transformation of sediment exposure to see if that improves residuals...
  
Now let's try log transformation of the sediment predictor. I will use the base 10 logarithmic scale because it seems suitable for the spread of sediment exposure in all cases.

```{r, echo=FALSE, warning=FALSE}
#?mixmeta

# Organizational Note: 
#All models have exposure concentration as its predictor. 
#All models with 'c' at the end of its name have fixed slopes, random intercepts.
#All models with 'd' at the end of its name have random slopes and intercepts.

# LINEAR FIXED AND RANDOM EFFECTS NOT ACCOUNTING FOR WITHIN-STUDY CORRELATIONS
log_mod_SS_fertil_b_1c <- mixmeta(smd ~ log10(Sed_level_standardized), S = vmd,
                       random =  ~ 1 | Comparison,
                       data = ES_SS_fertilization_b2, method = "ml")
log_mod_SS_fertil_b_1d <- mixmeta(smd ~ log10(Sed_level_standardized), S = vmd,
                      random =  ~ log10(Sed_level_standardized) | Comparison,
                      data = ES_SS_fertilization_b2, method = "ml")

# LINEAR FIXED AND RANDOM, NESTED EFFECTS NOT ACCOUNTING FOR WITHIN-STUDY CORRELATIONS
log_mod_SS_fertil_b_2c <- mixmeta(smd ~ log10(Sed_level_standardized), S = vmd,
                       random =  ~ 1 | Ref/Comparison,
                       data = ES_SS_fertilization_b2, method = "ml")
log_mod_SS_fertil_b_2d <- mixmeta(smd ~ log10(Sed_level_standardized), S = vmd,
                      random =  ~ log10(Sed_level_standardized) | Ref/Comparison,
                      data = ES_SS_fertilization_b2, method = "ml")

# LINEAR FIXED AND RANDOM, NESTED EFFECTS NOT ACCOUNTING FOR WITHIN-STUDY CORRELATIONS
log_mod_SS_fertil_b_3c <- mixmeta(smd ~ log10(Sed_level_standardized), S = vmd,
                       random =  ~ 1 | Ref_name/Comparison,
                       data = ES_SS_fertilization_b2, method = "ml")
log_mod_SS_fertil_b_3d <- mixmeta(smd ~ log10(Sed_level_standardized), S = vmd,
                      random =  ~ log10(Sed_level_standardized) | Ref_name/Comparison,
                      data = ES_SS_fertilization_b2, method = "ml")

# LINEAR FIXED AND RANDOM, NESTED EFFECTS NOT ACCOUNTING FOR WITHIN-STUDY CORRELATIONS
log_mod_SS_fertil_b_4c <- mixmeta(smd ~ log10(Sed_level_standardized), S = vmd,
                       random =  ~ 1 | Ref_name/Ref/Comparison,
                       data = ES_SS_fertilization_b2, method = "ml")
log_mod_SS_fertil_b_4d <- mixmeta(smd ~ log10(Sed_level_standardized), S = vmd,
                       random =  ~ log10(Sed_level_standardized) | Ref_name/Ref/Comparison,
                       data = ES_SS_fertilization_b2, method = "ml")
```

To account for within-comparison correlations in the mixmeta model, I replace the 'S' argument with a 'control' argument, which requires me to provide the covariance matrices, as done with the covar.smd function. 

```{r, echo=FALSE, warning=FALSE}
# COMPUTE THE WITHIN-COMPARISON CORRELATIONS 
# already done above but code repeated here...
#covar_SS_fertilization_b <- by(ES_SS_fertilization_b, ES_SS_fertilization_b$Comparison, function(x) 
#  covar.smd(Tx_mean, Tx_sd, Tx_n, "smd", method="hedges", data = x))


# LINEAR FIXED AND RANDOM EFFECTS ACCOUNTING FOR WITHIN-COMPARISON CORRELATIONS
#Code for covariance matrix to include for addSlist for Comparison random effect
newlist_FERT_log_b <- list(NA)
for (i in seq(1,length(covar_SS_fertilization_b))) {
newlist_FERT_log_b[i] <- list(covar_SS_fertilization_b[[i]]$S)
}
log_mod_SS_fertil_b_5c <- mixmeta(smd ~ log10(Sed_level_standardized),
                       random = ~ 1 | Comparison,
                       data=ES_SS_fertilization_b2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT_log_b))
log_mod_SS_fertil_b_5d <- mixmeta(smd ~ log10(Sed_level_standardized),
                       random = ~ log10(Sed_level_standardized) | Comparison,
                       data=ES_SS_fertilization_b2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT_log_b))


# LINEAR FIXED AND RANDOM, NESTED EFFECTS ACCOUNTING FOR WITHIN-COMPARISON & WITHIN-STUDY CORRELATIONS
#Code for covariance matrix to include for addSlist for Ref/Comparison
newlist_FERT_log_b2 <- list(NA) #collects the list of covariance matrices for the block diag matrix by reference for the nested hierarchial ref/comparison
templist_FERT_log_b <- list(NA) #holds temp list of covariance matrices associated with each reference
templist_FERT_log_b2 <-list(NA)
reflista <- ES_SS_fertilization_b %>% distinct(Ref,Ref_name,Comparison)
reflist <- reflista[,1]
for (i in seq(1,length(unique(reflista$Ref))))  {
  #pull the elements from covar_SS_fertilization_b that are all from the same reference [i]
  templist_FERT_log_b[i] <-list(covar_SS_fertilization_b[reflist==unique(reflista$Ref)[i]])
  for (j in seq(1,length(templist_FERT_log_b[[i]]))) {
  #for each comparison in the reference, pull out the covar matrices (element $S) and put in into templist_FERT_log_b2
     templist_FERT_log_b2[j] <- list(templist_FERT_log_b[[i]][[j]]$S)
  }
  #turn list of covars from all comparison in one reference into block diag matrix
  newlist_FERT_log_b2[i] <- list(bdiagMat(templist_FERT_log_b2))
  templist_FERT_log_b2 <- list(NA)
}
log_mod_SS_fertil_b_6c <- mixmeta(smd ~ log10(Sed_level_standardized),
                       random = ~ 1 | Ref/Comparison,
                       data=ES_SS_fertilization_b2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT_log_b2))
log_mod_SS_fertil_b_6d <- mixmeta(smd ~ log10(Sed_level_standardized),
                       random = ~ log10(Sed_level_standardized) | Ref/Comparison,
                       data=ES_SS_fertilization_b2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT_log_b2))


# LINEAR FIXED AND RANDOM, NESTED EFFECTS ACCOUNTING FOR WITHIN-COMPARISON & WITHIN-STUDY CORRELATIONS
#Code for covariance matrix to include for addSlist for Ref_name/Comparison
newlist_FERT_log_b3 <- list(NA) #collects the list of covariance matrices for the block diag matrix by reference for the nested hierarchial Ref_name/Comparison
templist_FERT_log_b3 <- list(NA) #holds temp list of covariance matrices associated with each reference
templist_FERT_log_b4 <-list(NA)
reflista <- ES_SS_fertilization_b %>% distinct(Ref,Ref_name,Comparison)
reflist <- reflista[,2]
for (i in seq(1,length(unique(reflista$Ref_name))))  {
  #pull the elements from covar_SS_fertilization_b that are all from the same reference [i]
  templist_FERT_log_b3[i] <-list(covar_SS_fertilization_b[reflist==unique(reflista$Ref_name)[i]])
  for (j in seq(1,length(templist_FERT_log_b3[[i]]))) {
  #for each comparison in the reference, pull out the covar matrices (element $S) and put in into templist_FERT_log_b4
     templist_FERT_log_b4[j] <- list(templist_FERT_log_b3[[i]][[j]]$S)
  }
  #turn list of covars from all comparison in one reference into block diag matrix
  newlist_FERT_log_b3[i] <- list(bdiagMat(templist_FERT_log_b4))
  templist_FERT_log_b4 <- list(NA)
}
log_mod_SS_fertil_b_7c <- mixmeta(smd ~ log10(Sed_level_standardized),
                       random = ~ 1 | Ref_name/Comparison,
                       data=ES_SS_fertilization_b2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT_log_b3))
log_mod_SS_fertil_b_7d <- mixmeta(smd ~ log10(Sed_level_standardized),
                       random = ~ log10(Sed_level_standardized) | Ref_name/Comparison,
                       data=ES_SS_fertilization_b2, method="ml", #dataset without controls
                       control=list(addSlist=newlist_FERT_log_b3))
```
  
### 3. Model Comparison and Summary
And now to compare relative fit of log-linear models...

```{r, echo=FALSE, warning=FALSE}
# Model Comparisons
AIC(log_mod_SS_fertil_b_1c, log_mod_SS_fertil_b_2c, log_mod_SS_fertil_b_3c, log_mod_SS_fertil_b_4c, log_mod_SS_fertil_b_5c, log_mod_SS_fertil_b_6c, log_mod_SS_fertil_b_7c, log_mod_SS_fertil_b_1d, log_mod_SS_fertil_b_2d, log_mod_SS_fertil_b_3d, log_mod_SS_fertil_b_4d, log_mod_SS_fertil_b_5d, log_mod_SS_fertil_b_6d, log_mod_SS_fertil_b_7d) 
#of these, model 3d has lowest AIC (but 2d,7d,6d within 2 AIC)
```
  
And now to evaluate residuals of models...

```{r, echo=FALSE, warning=FALSE}
# Residuals vs. Fitted Plots and Normal Q-Q Plots
op <- par(mfrow = c(2,2), mar = c(2,2,4,1))

resid_log_d_b <- resid(log_mod_SS_fertil_b_3d)
fitted_log_d_b <- fitted(log_mod_SS_fertil_b_3d)
plot(fitted_log_d_b, resid_log_d_b, main = "D: Hedges_d ~ log(mg_L), S = vmd,
     random =  ~ log(mg_L) | Ref/Comparison")
abline(0,0)

resid_log_d_b2 <- resid(log_mod_SS_fertil_b_2d)
fitted_log_d_b2 <- fitted(log_mod_SS_fertil_b_2d)
plot(fitted_log_d_b2, resid_log_d_b2, main = "D2: smd ~ log(mg_L), S = vmd,
     random =  ~ log(mg_L) | Ref_name/Comparison")
abline(0,0)

qqnorm(resid_log_d_b)
qqline(resid_log_d_b)
qqnorm(resid_log_d_b2)
qqline(resid_log_d_b2)

par(op)
```
  
Patterns:
1.  Residuals for best-fit models are very similar.
2.  Looks waaaaay better! Magnitude of residuals down and spread much more "acceptable".
3.  Q-Q plots still looking "meh" on low end of x-axis -- but no obvious reason to fit non-linear models.
  
  
### 4. Best-Fit Model Summary
  
#### i. Exposure concentration is PREDICTOR
Now I will predict the effect size along the exposure range and plot with confidence intervals.  

```{r, echo=FALSE, warning=FALSE}
summary(log_mod_SS_fertil_b_3d)
log_mod_SS_fertil_b_3d2 <- mixmeta(smd ~ log10(Sed_level_standardized) + Gsp, S = vmd,
                      random =  ~ log10(Sed_level_standardized) | Ref_name/Comparison,
                      data = ES_SS_fertilization_b2, method = "ml")
AIC(log_mod_SS_fertil_b_3d,log_mod_SS_fertil_b_3d2)

# PREDICT THE EFFECT SIZE FOR 30.4 mg/L FROM TWO MODELS (LOAEL identified by binary analyses)
#predict(log_mod_SS_fertil_b_3d, newdata=data.frame(Sed_level_standardized=30.4), ci=TRUE)
# PREDICT THE EFFECT SIZE FOR 25 mg/L FROM TWO MODELS (NOAEL identified by binary analyses)
#predict(log_mod_SS_fertil_b_3d, newdata=data.frame(Sed_level_standardized=25), ci=TRUE)

# PREDICT THE EFFECT SIZE AND PLOT WITH CONFIDENCE INTERVALS
pred_log_mod_SS_fertil_b_3d <- predict(log_mod_SS_fertil_b_3d, newdata=ES_SS_fertilization_b2, ci=TRUE)
ES_SS_fertilization_b2_CI4 <- cbind(ES_SS_fertilization_b2, pred_log_mod_SS_fertil_b_3d)
#head(ES_SS_fertilization_b2_CI4)
min_conc_d <- ES_SS_fertilization_b2_CI4 %>% 
  mutate(overlap0 = 0 >= ci.lb & 0 <= ci.ub) %>% 
  filter(overlap0==FALSE) %>% 
  filter(ci.ub<0) %>%
  summarize(min_conc_d=min(Sed_level_standardized))
min_conc_d2 <- as.numeric(min_conc_d)

ggplot(ES_SS_fertilization_b2_CI4, 
       aes(x = Sed_level_standardized,
           y = smd,
           color = Ref,
           ymin = smd-vmd,
           ymax = smd+vmd)) + 
  geom_pointrange() +
  labs(x = "Sediment exposure concentration (mg/L)",
       y = expression("Effect size (Hedges'"~italic(d)~"+/- variance of"~italic(d)~")"),
       color = "Study") +
  geom_abline(intercept=0, slope=0) +
  geom_vline(xintercept=min_conc_d2, linetype="dashed", color = "red") +
  geom_line(aes(x = Sed_level_standardized, y = fit), inherit.aes=FALSE) +
  geom_ribbon(aes(x = Sed_level_standardized, y = smd,
                  ymin = ci.lb, ymax = ci.ub), 
              fill = "grey70", alpha = .15, 
              show.legend=FALSE, inherit.aes=FALSE) +
  theme_classic() +
  scale_x_log10(limits = c(1,1000), breaks=c(1,10,100,1000,min_conc_d2), 
                label=c("1","10","100","1000",round(min_conc_d2,digits=1)))

#For Fig. 2C of report...
ggplot(ES_SS_fertilization_b2_CI4, 
       aes(x = Sed_level_standardized,
           y = smd, size = 4)) + 
  geom_point() +
  labs(x = "", y = "") +
  geom_abline(intercept=0, slope=0, linetype="dashed") +
  geom_line(aes(x = Sed_level_standardized, y = fit, size =2), inherit.aes=FALSE) +
  geom_vline(xintercept=min_conc_d2, linetype="dashed", color = "red", size = 2) +
  geom_ribbon(aes(x = Sed_level_standardized, y = smd,
                  ymin = ci.lb, ymax = ci.ub), 
              alpha = .15, 
              show.legend=FALSE, inherit.aes=FALSE) +
  theme_classic() +
  scale_x_log10(limits = c(1,1000), breaks=c(1,10,100,1000), 
                label=c("1","10","100","1000")) +
  theme(axis.text.x=element_text(size=rel(3)), 
        axis.text.y=element_text(size=rel(3)), legend.position = "none")
```
  